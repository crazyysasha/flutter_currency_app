// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'converter_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ConverterState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProcess,
    required TResult Function(Currency selected, Rate to) loadSuccess,
    required TResult Function(String message) loadFailure,
    required TResult Function(Currency selected, Rate to, double toAmount)
        convertSuccess,
    required TResult Function(String message) convertFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProcess,
    TResult? Function(Currency selected, Rate to)? loadSuccess,
    TResult? Function(String message)? loadFailure,
    TResult? Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult? Function(String message)? convertFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProcess,
    TResult Function(Currency selected, Rate to)? loadSuccess,
    TResult Function(String message)? loadFailure,
    TResult Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult Function(String message)? convertFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadInProcess value) loadInProcess,
    required TResult Function(_LoadSuccess value) loadSuccess,
    required TResult Function(_LoadFailure value) loadFailure,
    required TResult Function(_convertSuccess value) convertSuccess,
    required TResult Function(_convertFailure value) convertFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadInProcess value)? loadInProcess,
    TResult? Function(_LoadSuccess value)? loadSuccess,
    TResult? Function(_LoadFailure value)? loadFailure,
    TResult? Function(_convertSuccess value)? convertSuccess,
    TResult? Function(_convertFailure value)? convertFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadInProcess value)? loadInProcess,
    TResult Function(_LoadSuccess value)? loadSuccess,
    TResult Function(_LoadFailure value)? loadFailure,
    TResult Function(_convertSuccess value)? convertSuccess,
    TResult Function(_convertFailure value)? convertFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConverterStateCopyWith<$Res> {
  factory $ConverterStateCopyWith(
          ConverterState value, $Res Function(ConverterState) then) =
      _$ConverterStateCopyWithImpl<$Res, ConverterState>;
}

/// @nodoc
class _$ConverterStateCopyWithImpl<$Res, $Val extends ConverterState>
    implements $ConverterStateCopyWith<$Res> {
  _$ConverterStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$ConverterStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'ConverterState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProcess,
    required TResult Function(Currency selected, Rate to) loadSuccess,
    required TResult Function(String message) loadFailure,
    required TResult Function(Currency selected, Rate to, double toAmount)
        convertSuccess,
    required TResult Function(String message) convertFailure,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProcess,
    TResult? Function(Currency selected, Rate to)? loadSuccess,
    TResult? Function(String message)? loadFailure,
    TResult? Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult? Function(String message)? convertFailure,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProcess,
    TResult Function(Currency selected, Rate to)? loadSuccess,
    TResult Function(String message)? loadFailure,
    TResult Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult Function(String message)? convertFailure,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadInProcess value) loadInProcess,
    required TResult Function(_LoadSuccess value) loadSuccess,
    required TResult Function(_LoadFailure value) loadFailure,
    required TResult Function(_convertSuccess value) convertSuccess,
    required TResult Function(_convertFailure value) convertFailure,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadInProcess value)? loadInProcess,
    TResult? Function(_LoadSuccess value)? loadSuccess,
    TResult? Function(_LoadFailure value)? loadFailure,
    TResult? Function(_convertSuccess value)? convertSuccess,
    TResult? Function(_convertFailure value)? convertFailure,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadInProcess value)? loadInProcess,
    TResult Function(_LoadSuccess value)? loadSuccess,
    TResult Function(_LoadFailure value)? loadFailure,
    TResult Function(_convertSuccess value)? convertSuccess,
    TResult Function(_convertFailure value)? convertFailure,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements ConverterState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadInProcessImplCopyWith<$Res> {
  factory _$$LoadInProcessImplCopyWith(
          _$LoadInProcessImpl value, $Res Function(_$LoadInProcessImpl) then) =
      __$$LoadInProcessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadInProcessImplCopyWithImpl<$Res>
    extends _$ConverterStateCopyWithImpl<$Res, _$LoadInProcessImpl>
    implements _$$LoadInProcessImplCopyWith<$Res> {
  __$$LoadInProcessImplCopyWithImpl(
      _$LoadInProcessImpl _value, $Res Function(_$LoadInProcessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadInProcessImpl implements _LoadInProcess {
  const _$LoadInProcessImpl();

  @override
  String toString() {
    return 'ConverterState.loadInProcess()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadInProcessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProcess,
    required TResult Function(Currency selected, Rate to) loadSuccess,
    required TResult Function(String message) loadFailure,
    required TResult Function(Currency selected, Rate to, double toAmount)
        convertSuccess,
    required TResult Function(String message) convertFailure,
  }) {
    return loadInProcess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProcess,
    TResult? Function(Currency selected, Rate to)? loadSuccess,
    TResult? Function(String message)? loadFailure,
    TResult? Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult? Function(String message)? convertFailure,
  }) {
    return loadInProcess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProcess,
    TResult Function(Currency selected, Rate to)? loadSuccess,
    TResult Function(String message)? loadFailure,
    TResult Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult Function(String message)? convertFailure,
    required TResult orElse(),
  }) {
    if (loadInProcess != null) {
      return loadInProcess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadInProcess value) loadInProcess,
    required TResult Function(_LoadSuccess value) loadSuccess,
    required TResult Function(_LoadFailure value) loadFailure,
    required TResult Function(_convertSuccess value) convertSuccess,
    required TResult Function(_convertFailure value) convertFailure,
  }) {
    return loadInProcess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadInProcess value)? loadInProcess,
    TResult? Function(_LoadSuccess value)? loadSuccess,
    TResult? Function(_LoadFailure value)? loadFailure,
    TResult? Function(_convertSuccess value)? convertSuccess,
    TResult? Function(_convertFailure value)? convertFailure,
  }) {
    return loadInProcess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadInProcess value)? loadInProcess,
    TResult Function(_LoadSuccess value)? loadSuccess,
    TResult Function(_LoadFailure value)? loadFailure,
    TResult Function(_convertSuccess value)? convertSuccess,
    TResult Function(_convertFailure value)? convertFailure,
    required TResult orElse(),
  }) {
    if (loadInProcess != null) {
      return loadInProcess(this);
    }
    return orElse();
  }
}

abstract class _LoadInProcess implements ConverterState {
  const factory _LoadInProcess() = _$LoadInProcessImpl;
}

/// @nodoc
abstract class _$$LoadSuccessImplCopyWith<$Res> {
  factory _$$LoadSuccessImplCopyWith(
          _$LoadSuccessImpl value, $Res Function(_$LoadSuccessImpl) then) =
      __$$LoadSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Currency selected, Rate to});
}

/// @nodoc
class __$$LoadSuccessImplCopyWithImpl<$Res>
    extends _$ConverterStateCopyWithImpl<$Res, _$LoadSuccessImpl>
    implements _$$LoadSuccessImplCopyWith<$Res> {
  __$$LoadSuccessImplCopyWithImpl(
      _$LoadSuccessImpl _value, $Res Function(_$LoadSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selected = freezed,
    Object? to = freezed,
  }) {
    return _then(_$LoadSuccessImpl(
      selected: freezed == selected
          ? _value.selected
          : selected // ignore: cast_nullable_to_non_nullable
              as Currency,
      to: freezed == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as Rate,
    ));
  }
}

/// @nodoc

class _$LoadSuccessImpl implements _LoadSuccess {
  const _$LoadSuccessImpl({required this.selected, required this.to});

  @override
  final Currency selected;
  @override
  final Rate to;

  @override
  String toString() {
    return 'ConverterState.loadSuccess(selected: $selected, to: $to)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadSuccessImpl &&
            const DeepCollectionEquality().equals(other.selected, selected) &&
            const DeepCollectionEquality().equals(other.to, to));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(selected),
      const DeepCollectionEquality().hash(to));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadSuccessImplCopyWith<_$LoadSuccessImpl> get copyWith =>
      __$$LoadSuccessImplCopyWithImpl<_$LoadSuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProcess,
    required TResult Function(Currency selected, Rate to) loadSuccess,
    required TResult Function(String message) loadFailure,
    required TResult Function(Currency selected, Rate to, double toAmount)
        convertSuccess,
    required TResult Function(String message) convertFailure,
  }) {
    return loadSuccess(selected, to);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProcess,
    TResult? Function(Currency selected, Rate to)? loadSuccess,
    TResult? Function(String message)? loadFailure,
    TResult? Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult? Function(String message)? convertFailure,
  }) {
    return loadSuccess?.call(selected, to);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProcess,
    TResult Function(Currency selected, Rate to)? loadSuccess,
    TResult Function(String message)? loadFailure,
    TResult Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult Function(String message)? convertFailure,
    required TResult orElse(),
  }) {
    if (loadSuccess != null) {
      return loadSuccess(selected, to);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadInProcess value) loadInProcess,
    required TResult Function(_LoadSuccess value) loadSuccess,
    required TResult Function(_LoadFailure value) loadFailure,
    required TResult Function(_convertSuccess value) convertSuccess,
    required TResult Function(_convertFailure value) convertFailure,
  }) {
    return loadSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadInProcess value)? loadInProcess,
    TResult? Function(_LoadSuccess value)? loadSuccess,
    TResult? Function(_LoadFailure value)? loadFailure,
    TResult? Function(_convertSuccess value)? convertSuccess,
    TResult? Function(_convertFailure value)? convertFailure,
  }) {
    return loadSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadInProcess value)? loadInProcess,
    TResult Function(_LoadSuccess value)? loadSuccess,
    TResult Function(_LoadFailure value)? loadFailure,
    TResult Function(_convertSuccess value)? convertSuccess,
    TResult Function(_convertFailure value)? convertFailure,
    required TResult orElse(),
  }) {
    if (loadSuccess != null) {
      return loadSuccess(this);
    }
    return orElse();
  }
}

abstract class _LoadSuccess implements ConverterState {
  const factory _LoadSuccess(
      {required final Currency selected,
      required final Rate to}) = _$LoadSuccessImpl;

  Currency get selected;
  Rate get to;
  @JsonKey(ignore: true)
  _$$LoadSuccessImplCopyWith<_$LoadSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadFailureImplCopyWith<$Res> {
  factory _$$LoadFailureImplCopyWith(
          _$LoadFailureImpl value, $Res Function(_$LoadFailureImpl) then) =
      __$$LoadFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$LoadFailureImplCopyWithImpl<$Res>
    extends _$ConverterStateCopyWithImpl<$Res, _$LoadFailureImpl>
    implements _$$LoadFailureImplCopyWith<$Res> {
  __$$LoadFailureImplCopyWithImpl(
      _$LoadFailureImpl _value, $Res Function(_$LoadFailureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$LoadFailureImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LoadFailureImpl implements _LoadFailure {
  const _$LoadFailureImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'ConverterState.loadFailure(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadFailureImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadFailureImplCopyWith<_$LoadFailureImpl> get copyWith =>
      __$$LoadFailureImplCopyWithImpl<_$LoadFailureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProcess,
    required TResult Function(Currency selected, Rate to) loadSuccess,
    required TResult Function(String message) loadFailure,
    required TResult Function(Currency selected, Rate to, double toAmount)
        convertSuccess,
    required TResult Function(String message) convertFailure,
  }) {
    return loadFailure(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProcess,
    TResult? Function(Currency selected, Rate to)? loadSuccess,
    TResult? Function(String message)? loadFailure,
    TResult? Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult? Function(String message)? convertFailure,
  }) {
    return loadFailure?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProcess,
    TResult Function(Currency selected, Rate to)? loadSuccess,
    TResult Function(String message)? loadFailure,
    TResult Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult Function(String message)? convertFailure,
    required TResult orElse(),
  }) {
    if (loadFailure != null) {
      return loadFailure(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadInProcess value) loadInProcess,
    required TResult Function(_LoadSuccess value) loadSuccess,
    required TResult Function(_LoadFailure value) loadFailure,
    required TResult Function(_convertSuccess value) convertSuccess,
    required TResult Function(_convertFailure value) convertFailure,
  }) {
    return loadFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadInProcess value)? loadInProcess,
    TResult? Function(_LoadSuccess value)? loadSuccess,
    TResult? Function(_LoadFailure value)? loadFailure,
    TResult? Function(_convertSuccess value)? convertSuccess,
    TResult? Function(_convertFailure value)? convertFailure,
  }) {
    return loadFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadInProcess value)? loadInProcess,
    TResult Function(_LoadSuccess value)? loadSuccess,
    TResult Function(_LoadFailure value)? loadFailure,
    TResult Function(_convertSuccess value)? convertSuccess,
    TResult Function(_convertFailure value)? convertFailure,
    required TResult orElse(),
  }) {
    if (loadFailure != null) {
      return loadFailure(this);
    }
    return orElse();
  }
}

abstract class _LoadFailure implements ConverterState {
  const factory _LoadFailure({required final String message}) =
      _$LoadFailureImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$LoadFailureImplCopyWith<_$LoadFailureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$convertSuccessImplCopyWith<$Res> {
  factory _$$convertSuccessImplCopyWith(_$convertSuccessImpl value,
          $Res Function(_$convertSuccessImpl) then) =
      __$$convertSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Currency selected, Rate to, double toAmount});
}

/// @nodoc
class __$$convertSuccessImplCopyWithImpl<$Res>
    extends _$ConverterStateCopyWithImpl<$Res, _$convertSuccessImpl>
    implements _$$convertSuccessImplCopyWith<$Res> {
  __$$convertSuccessImplCopyWithImpl(
      _$convertSuccessImpl _value, $Res Function(_$convertSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selected = freezed,
    Object? to = freezed,
    Object? toAmount = null,
  }) {
    return _then(_$convertSuccessImpl(
      selected: freezed == selected
          ? _value.selected
          : selected // ignore: cast_nullable_to_non_nullable
              as Currency,
      to: freezed == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as Rate,
      toAmount: null == toAmount
          ? _value.toAmount
          : toAmount // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$convertSuccessImpl implements _convertSuccess {
  const _$convertSuccessImpl(
      {required this.selected, required this.to, required this.toAmount});

  @override
  final Currency selected;
  @override
  final Rate to;
  @override
  final double toAmount;

  @override
  String toString() {
    return 'ConverterState.convertSuccess(selected: $selected, to: $to, toAmount: $toAmount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$convertSuccessImpl &&
            const DeepCollectionEquality().equals(other.selected, selected) &&
            const DeepCollectionEquality().equals(other.to, to) &&
            (identical(other.toAmount, toAmount) ||
                other.toAmount == toAmount));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(selected),
      const DeepCollectionEquality().hash(to),
      toAmount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$convertSuccessImplCopyWith<_$convertSuccessImpl> get copyWith =>
      __$$convertSuccessImplCopyWithImpl<_$convertSuccessImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProcess,
    required TResult Function(Currency selected, Rate to) loadSuccess,
    required TResult Function(String message) loadFailure,
    required TResult Function(Currency selected, Rate to, double toAmount)
        convertSuccess,
    required TResult Function(String message) convertFailure,
  }) {
    return convertSuccess(selected, to, toAmount);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProcess,
    TResult? Function(Currency selected, Rate to)? loadSuccess,
    TResult? Function(String message)? loadFailure,
    TResult? Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult? Function(String message)? convertFailure,
  }) {
    return convertSuccess?.call(selected, to, toAmount);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProcess,
    TResult Function(Currency selected, Rate to)? loadSuccess,
    TResult Function(String message)? loadFailure,
    TResult Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult Function(String message)? convertFailure,
    required TResult orElse(),
  }) {
    if (convertSuccess != null) {
      return convertSuccess(selected, to, toAmount);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadInProcess value) loadInProcess,
    required TResult Function(_LoadSuccess value) loadSuccess,
    required TResult Function(_LoadFailure value) loadFailure,
    required TResult Function(_convertSuccess value) convertSuccess,
    required TResult Function(_convertFailure value) convertFailure,
  }) {
    return convertSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadInProcess value)? loadInProcess,
    TResult? Function(_LoadSuccess value)? loadSuccess,
    TResult? Function(_LoadFailure value)? loadFailure,
    TResult? Function(_convertSuccess value)? convertSuccess,
    TResult? Function(_convertFailure value)? convertFailure,
  }) {
    return convertSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadInProcess value)? loadInProcess,
    TResult Function(_LoadSuccess value)? loadSuccess,
    TResult Function(_LoadFailure value)? loadFailure,
    TResult Function(_convertSuccess value)? convertSuccess,
    TResult Function(_convertFailure value)? convertFailure,
    required TResult orElse(),
  }) {
    if (convertSuccess != null) {
      return convertSuccess(this);
    }
    return orElse();
  }
}

abstract class _convertSuccess implements ConverterState {
  const factory _convertSuccess(
      {required final Currency selected,
      required final Rate to,
      required final double toAmount}) = _$convertSuccessImpl;

  Currency get selected;
  Rate get to;
  double get toAmount;
  @JsonKey(ignore: true)
  _$$convertSuccessImplCopyWith<_$convertSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$convertFailureImplCopyWith<$Res> {
  factory _$$convertFailureImplCopyWith(_$convertFailureImpl value,
          $Res Function(_$convertFailureImpl) then) =
      __$$convertFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$convertFailureImplCopyWithImpl<$Res>
    extends _$ConverterStateCopyWithImpl<$Res, _$convertFailureImpl>
    implements _$$convertFailureImplCopyWith<$Res> {
  __$$convertFailureImplCopyWithImpl(
      _$convertFailureImpl _value, $Res Function(_$convertFailureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$convertFailureImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$convertFailureImpl implements _convertFailure {
  const _$convertFailureImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'ConverterState.convertFailure(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$convertFailureImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$convertFailureImplCopyWith<_$convertFailureImpl> get copyWith =>
      __$$convertFailureImplCopyWithImpl<_$convertFailureImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProcess,
    required TResult Function(Currency selected, Rate to) loadSuccess,
    required TResult Function(String message) loadFailure,
    required TResult Function(Currency selected, Rate to, double toAmount)
        convertSuccess,
    required TResult Function(String message) convertFailure,
  }) {
    return convertFailure(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProcess,
    TResult? Function(Currency selected, Rate to)? loadSuccess,
    TResult? Function(String message)? loadFailure,
    TResult? Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult? Function(String message)? convertFailure,
  }) {
    return convertFailure?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProcess,
    TResult Function(Currency selected, Rate to)? loadSuccess,
    TResult Function(String message)? loadFailure,
    TResult Function(Currency selected, Rate to, double toAmount)?
        convertSuccess,
    TResult Function(String message)? convertFailure,
    required TResult orElse(),
  }) {
    if (convertFailure != null) {
      return convertFailure(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_LoadInProcess value) loadInProcess,
    required TResult Function(_LoadSuccess value) loadSuccess,
    required TResult Function(_LoadFailure value) loadFailure,
    required TResult Function(_convertSuccess value) convertSuccess,
    required TResult Function(_convertFailure value) convertFailure,
  }) {
    return convertFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_LoadInProcess value)? loadInProcess,
    TResult? Function(_LoadSuccess value)? loadSuccess,
    TResult? Function(_LoadFailure value)? loadFailure,
    TResult? Function(_convertSuccess value)? convertSuccess,
    TResult? Function(_convertFailure value)? convertFailure,
  }) {
    return convertFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_LoadInProcess value)? loadInProcess,
    TResult Function(_LoadSuccess value)? loadSuccess,
    TResult Function(_LoadFailure value)? loadFailure,
    TResult Function(_convertSuccess value)? convertSuccess,
    TResult Function(_convertFailure value)? convertFailure,
    required TResult orElse(),
  }) {
    if (convertFailure != null) {
      return convertFailure(this);
    }
    return orElse();
  }
}

abstract class _convertFailure implements ConverterState {
  const factory _convertFailure({required final String message}) =
      _$convertFailureImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$convertFailureImplCopyWith<_$convertFailureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
